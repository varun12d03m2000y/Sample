import org.apache.spark.sql.functions._
import org.apache.spark.sql.{SparkSession, Row}
import org.apache.spark.ml.feature.{StopWordsRemover, Tokenizer}
import scala.collection.mutable.ArrayBuffer

object AddressMatching {

  def main(args: Array[String]): Unit = {
    val spark = SparkSession.builder()
      .appName("Address Matching")
      .master("local[*]")
      .getOrCreate()

    // Input path
    val inputPath = "/edl/hdfs/jffv-mns/testaddress/input/query-impala-88364.csv"
    val data = spark.read.option("header", "true").csv(inputPath)

    // Normalize addresses
    val normalizeUDf = udf((address: String) => {
      Option(address).map(_.toLowerCase
        .replaceAll("\\b(st|road|rd|avenue|ave|boulevard|blvd|way|circle|pk|park)\\b", "st")
        .replaceAll("[^a-z0-9\\s]", "")
        .trim).getOrElse("")
    })

    val normalizedDf = data
      .withColumn("normalized_address", normalizeUDf(col("address")))
      .withColumn("normalized_postal_cd", col("postal_cd").substr(1, 5))

    // Tokenize and remove stopwords
    val tokenizer = new Tokenizer().setInputCol("normalized_address").setOutputCol("tokens")
    val tokenizedDf = tokenizer.transform(normalizedDf)

    val remover = new StopWordsRemover().setInputCol("tokens").setOutputCol("filtered_tokens")
    val filteredDf = remover.transform(tokenizedDf)

    // Group by postal code and create address groups
    val groupedDf = filteredDf.groupBy("normalized_postal_cd").agg(
      collect_list(struct("normalized_address", "filtered_tokens")).as("address_group")
    )

    // UDF to compute Jaccard similarity
    val similarityUDF = udf((addresses: Seq[Row]) => {
      val results = ArrayBuffer[(String, String, Double)]()
      for (i <- addresses.indices; j <- i + 1 until addresses.size) {
        val addr1 = addresses(i)
        val addr2 = addresses(j)
        val tokens1 = addr1.getAs[Seq[String]]("filtered_tokens")
        val tokens2 = addr2.getAs[Seq[String]]("filtered_tokens")
        val intersection = tokens1.intersect(tokens2).size.toDouble
        val union = tokens1.union(tokens2).distinct.size.toDouble
        val score = if (union > 0) intersection / union else 0.0
        results += ((addr1.getAs[String]("normalized_address"), addr2.getAs[String]("normalized_address"), score))
      }
      results
    })

    // Compute comparisons
    val comparisonDf = groupedDf.withColumn("comparisons", similarityUDF(col("address_group")))

    // Flatten comparisons and create a new DataFrame with address pairs and their similarity score
    val flatDf = comparisonDf
      .select(explode(col("comparisons")).as("comparison"))
      .select(
        col("comparison._1").as("address_1"),
        col("comparison._2").as("address_2"),
        col("comparison._3").as("similarity_score")
      )

    // Filter duplicates: similarity_score = 1.0 (identical addresses)
    val duplicateDf = flatDf.filter(col("similarity_score") === 1.0)

    // Get the distinct addresses from the duplicate list
    val duplicateAddresses = duplicateDf
      .select(col("address_2"))
      .union(duplicateDf.select(col("address_1")))
      .distinct()

    // Filter out duplicates from the original dataset
    val nonDuplicateDf = filteredDf.join(
      duplicateAddresses,
      filteredDf("normalized_address") === duplicateAddresses("address_2"),
      "left_anti"
    )

    // Flatten the tokens and filtered_tokens columns into strings
    val flatNonDuplicateDf = nonDuplicateDf
      .withColumn("tokens_str", concat_ws(" ", col("tokens")))
      .withColumn("filtered_tokens_str", concat_ws(" ", col("filtered_tokens")))
      .drop("tokens", "filtered_tokens") // Drop the original array columns

    // Output paths
    val similarityOutputPath = "/edl/hdfs/jffv-mns/testaddress/output/address_similarity.csv"
    val uniqueAddressOutputPath = "/edl/hdfs/jffv-mns/testaddress/output/unique_addresses.csv"

    // Write address similarity results
    flatDf.write
      .mode("overwrite")
      .option("header", "true")
      .csv(similarityOutputPath)

    // Write unique address records
    flatNonDuplicateDf.write
      .mode("overwrite")
      .option("header", "true")
      .csv(uniqueAddressOutputPath)

    // Count duplicates removed
    val duplicateCount = duplicateAddresses.count()

    // Print how many duplicates were removed
    println(s"Number of duplicate addresses removed: $duplicateCount")
    println(s"Address similarity results have been written to $similarityOutputPath")
    println(s"Unique address records have been written to $uniqueAddressOutputPath")
  }
}






Here is the full list with `" "` added to each word:

"ALLEE" -> " " "ALLEY" -> " " "ALLY" -> " " "ALY" -> " " "ANEX" -> " " "ANNEX" -> " " "ANNX" -> " " "ANX" -> " " "ARC" -> " " "ARCADE" -> " " "AV" -> " " "AVE" -> " " "AVEN" -> " " "AVENU" -> " " "AVENUE" -> " " "AVN" -> " " "AVNUE" -> " " "BAYOO" -> " " "BAYOU" -> " " "BCH" -> " " "BEACH" -> " " "BEND" -> " " "BND" -> " " "BLF" -> " " "BLUF" -> " " "BLUFF" -> " " "BLUFFS" -> " " "BOT" -> " " "BTM" -> " " "BOTTM" -> " " "BOTTOM" -> " " "BLVD" -> " " "BOUL" -> " " "BOULEVARD" -> " " "BOULV" -> " " "BR" -> " " "BRNCH" -> " " "BRANCH" -> " " "BRDGE" -> " " "BRG" -> " " "BRIDGE" -> " " "BRK" -> " " "BROOK" -> " " "BROOKS" -> " " "BURG" -> " " "BURGS" -> " " "BYP" -> " " "BYPA" -> " " "BYPAS" -> " " "BYPASS" -> " " "BYPS" -> " " "CAMP" -> " " "CP" -> " " "CMP" -> " " "CANYN" -> " " "CANYON" -> " " "CNYN" -> " " "CAPE" -> " " "CPE" -> " " "CAUSEWAY" -> " " "CAUSWA" -> " " "CSWY" -> " " "CEN" -> " " "CENT" -> " " "CENTER" -> " " "CENTR" -> " " "CENTRE" -> " " "CNTER" -> " " "CNTR" -> " " "CTR" -> " " "CENTERS" -> " " "CIR" -> " " "CIRC" -> " " "CIRCL" -> " " "CIRCLE" -> " " "CRCL" -> " " "CRCLE" -> " " "CIRCLES" -> " " "CLF" -> " " "CLIFF" -> " " "CLFS" -> " " "CLIFFS" -> " " "CLB" -> " " "CLUB" -> " " "COMMON" -> " " "COMMONS" -> " " "COR" -> " " "CORNER" -> " " "CORNERS" -> " " "CORS" -> " " "COURSE" -> " " "CRSE" -> " " "COURT" -> " " "CT" -> " " "COURTS" -> " " "CTS" -> " " "COVE" -> " " "CV" -> " " "COVES" -> " " "CREEK" -> " " "CRK" -> " " "CRESCENT" -> " " "CRES" -> " " "CRSENT" -> " " "CRSNT" -> " " "CREST" -> " " "CROSSING" -> " " "CRSSNG" -> " " "XING" -> " " "CROSSROAD" -> " " "CROSSROADS" -> " " "CURVE" -> " " "DALE" -> " " "DL" -> " " "DAM" -> " " "DM" -> " " "DIV" -> " " "DIVIDE" -> " " "DV" -> " " "DVD" -> " " "DR" -> " " "DRIV" -> " " "DRIVE" -> " " "DRV" -> " " "DRIVES" -> " " "EST" -> " " "ESTATE" -> " " "ESTATES" -> " " "ESTS" -> " " "EXP" -> " " "EXPR" -> " " "EXPRESS" -> " " "EXPRESSWAY" -> " " "EXPW" -> " " "EXPY" -> " " "EXT" -> " " "EXTENSION" -> " " "EXTN" -> " " "EXTNSN" -> " " "EXTS" -> " " "FALL" -> " " "FALLS" -> " " "FLS" -> " " "FERRY" -> " " "FRRY" -> " " "FRY" -> " " "FIELD" -> " " "FLD" -> " " "FIELDS" -> " " "FLDS" -> " " "FLAT" -> " " "FLT" -> " " "FLATS" -> " " "FLTS" -> " " "FORD" -> " " "FRD" -> " " "FORDS" -> " " "FOREST" -> " " "FORESTS" -> " " "FRST" -> " " "FORG" -> " " "FORGE" -> " " "FRG" -> " " "FORGES" -> " " "FORK" -> " " "FRK" -> " " "FORKS" -> " " "FRKS" -> " " "FORT" -> " " "FRT" -> " " "FT" -> " " "FREEWAY" -> " " "FREEWY" -> " " "FRWAY" -> " " "FRWY" -> " " "FWY" -> " " "GARDEN" -> " " "GARDN" -> " " "GRDEN" -> " " "GRDN" -> " " "GARDENS" -> " " "GDNS" -> " " "GRDNS" -> " " "GATEWAY" -> " " "GATEWY" -> " " "GATWAY" -> " " "GTWAY" -> " " "GTWY" -> " " "GLEN" -> " " "GLN" -> " " "GLENS" -> " " "GREEN" -> " " "GRN" -> " " "GREENS" -> " " "GROV" -> " " "GROVE" -> " " "GRV" -> " " "GROVES" -> " " "HARB" -> " " "HARBOR" -> " " "HARBR" -> " " "HBR" -> " " "HRBOR" -> " " "HARBORS" -> " " "HAVEN" -> " " "HVN" -> " " "HT" -> " " "HTS" -> " " "HIGHWAY" -> " " "HIGHWY" -> " " "HIWAY" -> " " "HIWY" -> " " "HWAY" -> " " "HWY" -> " " "HILL" -> " " "HL" -> " " "HILLS" -> " " "HLS" -> " " "HLLW" -> " " "HOLLOW" -> " " "HOLLOWS" -> " " "HOLW" -> " " "HOLWS" -> " " "INLT" -> " " "IS" -> " " "ISLAND" -> " " "ISLND" -> " " "ISLANDS" -> " " "ISLNDS" -> " " "ISS" -> " " "ISLE" -> " " "ISLES" -> " " "JCT" -> " " "JCTION" -> " " "JCTN" -> " " "JUNCTION" -> " " "JUNCTN" -> " " "JUNCTON" -> " " "JCTNS" -> " " "JCTS" -> " " "JUNCTIONS" -> " " "KEY" -> " " "KY" -> " " "KEYS" -> " " "KYS" -> " " "KNL" -> " " "KNOL" -> " " "KNOLL" -> " " "KNLS" -> " " "KNOLLS" -> " " "LK" -> " " "LAKE" -> " " "LKS" -> " " "LAKES" -> " " "LAND" -> " " "LANDING" -> " " "LNDG" -> " " "LNDNG" -> " " "LANE" -> " " "LN" -> " " "LGT" -> " " "LIGHT" -> " " "LIGHTS" -> " " "LF" -> " " "LOAF" -> " " "LCK" -> " " "LOCK" -> " " "LCKS" -> " " "LOCKS" -> " " "LDG" -> " " "LDGE" -> " " "LODG" -> " " "LODGE" -> " " "LOOP" -> " " "LOOPS" -> " " "MALL" -> " " "MNR" -> " " "MANOR" -> " " "MANORS" -> " " "MNRS" -> " " "MEADOW" -> " " "MDW" -> " " "MDWS" -> " " "MEADOWS" -> " " "MEDOWS" -> " " "MEWS" -> " " "MILL" -> " " "MILLS" -> " " "MISSN" -> " " "MSSN" -> " " "MOTORWAY" -> " " "MNT" -> " " "MT" -> " " "MOUNT" -> " " "MNTAIN" -> " " "MNTN" -> " " "MOUNTAIN" -> " " "MOUNTIN" -> " " "MTIN" -> " " "MTN" -> " " "MNTNS" -> " " "MOUNTAINS" -> " " "NCK" -> " " "NECK" -> " " "ORCH" -> " " "ORCHARD" -> " " "ORCHRD" -> " " "OVAL" -> " " "OVL" -> " " "OVERPASS" -> " " "PARK" -> " " "PRK" -> " " "PARKS" -> " " "PARKWAY" -> " " "PARKWY" -> " " "PKWAY" -> " " "PKWY" -> " " "PKY" -> " " "PARKWAYS" -> " " "PKWYS" -> " " "PASS" -> " " "PASSAGE" -> " " "PATH" -> " " "PATHS" -> " " "PIKE" -> " " "PIKES" -> " " "PINE" -> " " "PINES" -> " " "PNES" -> " " "PL" -> " " "PLAIN" -> " " "PLN" -> " " "PLAINS" -> " " "PLNS" -> " " "PLAZA" -> " " "PLZ" -> " " "PLZA" -> " " "POINT" -> " " "PT" -> " " "POINTS" -> " " "PTS" -> " " "PORT" -> " " "PRT" -> " " "PORTS" -> " " "PRTS" -> " " "PR" -> " " "PRAIRIE" -> " " "PRR" -> " " "RAD" -> " " "RADIAL" -> " " "RADIEL" -> " " "RADL" -> " " "RAMP" -> " " "RANCH" -> " " "RANCHES" -> " " "RNCH" -> " " "RNCHS" -> " " "RAPID" -> " " "RPD" -> " " "RAPIDS" -> " " "RPDS" -> " " "REST" -> " " "RST" -> " " "RDG" -> " " "RDGE" -> " " "RIDGE" -> " " "RDGS" -> " " "RIDGES" -> " " "RIV" -> " " "RIVER" -> " " "RVR" -> " " "RIVR" -> " " "RD" -> " " "ROAD" -> " " "ROADS" -> " " "RDS" -> " " "ROUTE" -> " " "ROW" -> " " "RUE" -> " " "RUN" -> " " "SHL" -> " " "SHOAL" -> " "
